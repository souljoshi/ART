struct color { double r,g,b; }
color::color(double _r, double _g, double _b) { r =_r; g=_g;b=_b;}
double PI = 3.14159265;

struct color color;

shape rectangle
{
    vec bl; // bottom left corner
    double w,h; // widht height
    int fill;
    struct color c;
}

rectangle::rectangle(vec _bl, double _w, double _h , int f,struct color ci)
{
    bl = _bl;
    w = _w;
    h = _h;
    fill = f;
    c = ci;
}

void rectangle::draw()
{
    setcolor(c.r, c.g, c.b);
    if (fill == 1)
        <<
            drawpoint(bl);drawpoint(bl+<w,0.0>);drawpoint(bl+<0.0,h>);
            drawpoint(bl + <w,h>);drawpoint(bl+<w,0.0>);drawpoint(bl+<0.0,h>);
        >>
    else
        [
            drawpoint(bl);drawpoint(bl+<w,0.0>);
            drawpoint(bl+<w,0.0>);drawpoint(bl+<w,h>);
            drawpoint(bl+<w,h>);drawpoint(bl+<0.0,h>);
            drawpoint(bl+<0.0,h>);drawpoint(bl);
        ]

}

int max =10;

double dw()
{

    double h = 1.0 / max;
    if (h >= 0.2) h = 0.1;
    return h;
}

double hw = 0.43;
double sw = 0.43/6;
double sh = 1.0;
// A single hanoi disk
shape hdisk { int id; shape rectangle r;}

hdisk::hdisk(int i)
{ 
    id = i;

    r = rectangle(<0.0,0.0>,(hw - sw)*i/max + sw*1.5, dw(), 1, color(1.0, 1.0/max *(max -i),1.0/max *(max -i)));
}

void hdisk::setloc(vec v) { r.bl = v;}
void hdisk::incloc(vec v) { r.bl += v;}
void hdisk::decloc(vec v) { r.bl -= v;}

void hdisk::draw() { r.draw(); }

struct color cblue = {196.0/255.0, 216.0/255.0, 226.0/255.0};

// stack for placing disks
shape hstack 
{
    shape rectangle s;
    vec base;
    int top;
    shape hdisk[256] data;
    // animation state
    int being_poped;
    int being_pushed;
    int done_poped;
    int done_pushed;
    // debug string
    string dbg;
}

hstack::hstack(vec bz,string d)
{
    base = bz;
    dbg = d;
    s = rectangle(bz- <sw/2.0,0.0>, sw , 1.0, 1,cblue );
    top = -1;

    being_poped = being_pushed = done_poped = done_pushed = 0;
}
void hstack::draw()
{
    s.draw();
    for (int i = 0; i <= top;i++)
        data[i].draw();
}

// stack functions
int hstack::is_empty() { return top == -1; }
int hstack::is_full() { return top == 256; }
int hstack::size() { return (top + 1);}

shape hdisk hstack::top() { 
   // if (is_empty()) {
       // prints(dbg);prints(": accessing empty stack\n");
   // } 
    return data[top]; 
}
shape hdisk hstack::pop() { 
    if (is_empty()) {
        prints(dbg);prints(": poping empty stack\n");
    }
    return data[top--]; 
}
void hstack::push(shape hdisk x){
    if(is_full()) {
       prints(dbg); prints (": stack overflow\n");
    }
    x.setloc(< base[0] - x.r.w/2, base[1] + (++top) *dw()>);
    data[top] = x;
}

// returns 1 to signal pop animation is done
int hstack::animatepop(double dt)
{
    if (done_poped){
        done_poped = 0;
        being_poped = 0;
        return 1;
    }
    being_poped = 1;
    data[top].incloc(<0.0,dt>);
    if (( data[top].r.bl[1])  > ( dw() + s.h + s.bl[1]))
        done_poped = 1; 
    return 0;
}

int hstack::animatedpush(double dt, shape hdisk &d)
{
    if (done_pushed){
        done_pushed = 0;
        being_pushed = 0;
        return 1;
    }
    if (being_pushed == 0){
        d.setloc(base + <-d.r.w/2,s.h>);
    }
    being_pushed = 1;
    d.decloc(<0.0,dt>);
    if (d.r.bl[1] <= (top + 1)*dw() + base[1])
        done_pushed = 1; 
    return 0;
}

int movstate = 0;
shape hdisk d; // temporary disk
// Move from one stack to another 
// 
int sign (double d)
{
    if (d > 0) return 1;
    else if (d <0)return -1;
    else return 0;
}
int animatedmove(shape hstack &s1, shape hstack &s2, double dt)
{
    if (movstate == 0) {
        if(s1.animatepop(dt)){
                d = s1.pop();
                movstate = 1;
                // add it so we can draw it out selves
                addshape(d);
            }
    }
    // move to the right
    else if (movstate == 1)
    {
        int s = sign(s2.base[0]-s1.base[0]);
        if (s*d.r.bl[0] <= s*(s2.base[0] - d.r.w/2))
            d.incloc(s*<dt,0.0>);
        else{
            movstate = 2;
        }
    }
    // lower a bit
    else if (movstate == 2)
    {
        if (d.r.bl[1] > s2.base[1] + s2.s.h)
            d.decloc(<0.0,dt>);
        else
            movstate = 3;
    }
    else if (movstate == 3)
    {
        if(s2.animatedpush(dt,d)){
            movstate = 4;
        }
    }
    else  {
        s2.push(d);
        movstate = 0;
        d.setloc(<100,100>); /* Move of screen */
        return 1;
    }
}

int pow2(int n)
{
    if (n <= 0)
        return 1;
    else return 2*pow2(n-1);
}

int btwn = 0;
int bcond(int cond, int st) 
{
    if (movstate == 0)
        return cond;
    else
        return st == btwn;
}
// Function to implement legal movement between
// two poles
int movebetween(shape hstack &s, shape hstack &d, double dt)
{
    // When sourcee  is empty
    if (bcond(s.is_empty(),1))
    {
        btwn = 1;
        return animatedmove(d, s,dt);
    }
 
    // When d is empty
    else if (bcond(d.is_empty(),2))
    {
        btwn = 2;
        return animatedmove(s,d,dt);
    }
 
    // When top disk of s > top disk of d
    else if (bcond(s.top().id > d.top().id,3))
    {
        btwn = 3;
       return animatedmove(d, s,dt);
    }
 
    // When top disk of pole1 < top disk of pole2
    else
    {
        btwn = 3;
       return animatedmove(s,d,dt);
    }
}

void movebetweenandinc (shape hstack &s, shape hstack &d,double dt,int &i)
{
    if (movebetween(s,d,dt))
        i++;
}

int main()
{
    shape hstack src = hstack(<-2.0/3.0,-1>,"src"); // source
    shape hstack aux = hstack(<0.0,-1>,"aux");      // aux
    shape hstack dest = hstack(<2.0/3.0,-1>,"dest");  // dest
    for (int i = max ; i >= 1;i--)
        src.push(hdisk(i));

    addshape(src,dest,aux);

    int i = 1;
    int max_moves = pow2(max);
    double dt = 0.01;
    printi(max %2 );prints("\n");
    frameloop (fps = 240 ; frames = 100000) 
   {
        //prints("i: ");printi(i);prints("\n");
        prints(src.dbg);prints(": ");printi(src.size());prints(" ");
        prints(aux.dbg);prints(": ");printi(aux.size());prints(" ");
        prints(dest.dbg);prints(": ");printi(dest.size());prints(" \n");
        if (i < max_moves) {
            if (i % 3 == 1){
                if (max % 2 == 1)
                    movebetweenandinc(src, dest, dt, i);
                else
                    movebetweenandinc(src, aux, dt, i);
            }
 
            else if (i % 3 == 2){
                if (max % 2 == 1)
                    movebetweenandinc(src, aux, dt, i);
                else
                    movebetweenandinc(src, dest, dt, i);
            }
 
            else if (i % 3 == 0){
                if (max % 2 == 1)
                    movebetweenandinc(aux, dest, dt, i);
                else
                    movebetweenandinc(dest, aux, dt, i);
            }
        }
   }
}