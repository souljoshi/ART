struct color { double r,g,b; }
double PI;

struct color color;

/* A cicle with origin at x,y with radius r */
shape circle 
{
    double r;
    double ox, oy;
}

circle::circle(double x, double y, double radius)
{
    ox = x; oy = y;
    r = radius;
}


// This is the function from the example
/* Notice that it only uses draw points. */
void circle::draw()
{
    setcolor(color.r, color.g, color.b);
    // Single circle is 1000 points YIKES
[
    for (double theta = 0.0; theta <= 2  * PI; theta += .05 * PI) {
        drawpoint(ox + r*cos(theta - 0.05*PI), oy + r*sin(theta-0.05*PI));
        drawpoint(ox + r*cos(theta), oy + r*sin(theta));
    }
    drawpoint(ox + r, oy);
]
}

shape disk
{
    double r;
    double ox, oy;
}

disk::disk(double x, double y, double radius)
{
    ox = x; oy = y;
    r = radius;
}


// This is the function from the example
/* Notice that it only uses draw points. */
void disk::draw()
{
    setcolor(color.r, color.g, color.b);
    // Single circle is 1000 points YIKES
<
    for (double theta = 0.0; theta <= 2  * PI; theta += .05 * PI) {
         drawpoint(ox , oy);
        drawpoint(ox + r*cos(theta - 0.05*PI), oy + r*sin(theta-0.05*PI));
        drawpoint(ox + r*cos(theta), oy + r*sin(theta));
    }
>
}
// this is a path shape
// a drawable circular buffer of points
shape path
{
    int f, b;
    double[128] px;
    double[128] py;
}

path::path() { f = 0; b = 0; }

int MOD(int x) 
{
    return x % 128;  
} 

void path::draw()
{
    setcolor(color.r, color.g, color.b);
[
    if ( f != b)
    for (int i = MOD(f) + 1;  MOD(i) != MOD(b); i+=1) {    
        drawpoint(px[MOD(i-1)], py[MOD(i-1)]);
        drawpoint(px[MOD(i)], py[MOD(i)]);
    }
]
   
}


void path::add_point(double x, double y)
{
    px[MOD(b)] = x;
    py[MOD(b)] = y;
    b+=1;

    // if we run out of space
    if (MOD(b) == MOD(f))
        f+=1;
}

void path::reset() { f = b = 0;}

int main()
{   

    shape circle c = circle(0.0, 0.0, 0.25);
    shape disk d  = disk(0.0, 0.0, 0.15);
    shape path p = path();
    double theta = 0.0;
    double ox = 0.0, oy = 0.0;
    PI = 3.14159265;
    
    addshape(c); 
    addshape(p);

    // first in red
    color.r = 1.0; color.b = color.g = 0.0;
    printf(theta);
    printc('\n');
   timeloop (dt = 0.001 ; end = 10.0)
    {
        theta += .010 * PI;
        c.ox = ox + 1.3 * c.r * cos(theta);
        c.oy = oy + 1.3 * c.r * sin(theta);
        p.add_point(c.ox, c.oy);
    }
    printf(theta);
    printc('\n');


    // then in blue
    color.b = 1.0; color.r = color.g = 0.0;

 // Readd shapes since they removed after the end of a time loop
    addshape(d); 
    addshape(p);
    p.reset();

    timeloop (dt = 0.001; end = 10.0)
    {
        theta += .010 * PI;
        d.ox = ox + 1.3 * d.r * cos(theta);
        d.oy = oy + 1.3 * d.r * sin(theta);
        p.add_point(d.ox, d.oy);
    }  
    return 0;
}